<!DOCTYPE html>
<html>
<title>Thesis</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="Aux/w3/w3.css"> <!--relative path dosn't work -->
<link rel="stylesheet" href="Aux/w3/w3-theme-black.css">
<link rel="stylesheet" href="Aux/w3/Roboto.css">
<link rel="stylesheet" href="Aux/w3/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<!-- This style is for changing colors of links according to visit 
<style>  
a:link {
    color: green;
    background-color: transparent;
    text-decoration: none;
}
a:visited {
    color: pink;
    background-color: transparent;
    text-decoration: none;
}
a:hover {
    color: red;
    background-color: transparent;
    text-decoration: underline;
}
a:active {
    color: yellow;
    background-color: transparent;
    text-decoration: underline;
}
</style>
-->

<body contentEditable = "false";>

<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()">
    <i class="fa fa-bars"></i> </a>   
    <a href="index.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">HOME</a>
    <a href="theory.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">THEORY</a>
    <a href="simulator.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">SIMULATOR</a>
    <a href="pi.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">RASPBERRY PI</a>
  </div>
</div>


<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <h4 class="w3-bar-item"><b>Menu</b></h4>
  <a class="w3-bar-item w3-button w3-hover-black" href="#abs">Abstract</a>
  <a class="w3-bar-item w3-button w3-hover-black" href="#intro">Introduction</a>
  <a class="w3-bar-item w3-button w3-hover-black" href="#param">Comparision Parameters</a>
  <a class="w3-bar-item w3-button w3-hover-black" href="#algs">Scheduling Algorithms</a>
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  <div class="w3-row w3-padding-64">
    <div class="w3-container">
      <h2 class="w3-text-teal" >Hybrid scheduling algorithm using modified LLF algorithm and particle swarm optimization for power aware uniprocessor system </h2>
<h4  class="w3-text-teal" id="abs" > Abstract </h4>
The analysis of various scheduling policies being followed and being proposes for the  embedded system kernel is done. It is concluded that the dynamic and power aware scheduler is needed for the real time operating systems. The Least Laxity First algorithm with the use of Particle Swarm Optimization may be very useful in the case of real time tasks where the hard real time tasks may not be scheduled using other techniques. By using least laxity first and particle swarm optimization technique we have choosen to create a hybrid scheduling algorithm that may utilize the advantages of both the policies in order to get a scheduling policy that is having more utilization and power optimization. LLF algorithm is having the scheduling criteria as laxity
 or slack it is related to the power aware policies e.g DVFS with the slack management and the modified least laxity first is having criteria for selection of scheduling point so the the processor overhead is less. Further, if a hard real time task is missing using the modified least laxity first algorithm we can try the particle swarm optimization so the the the task never miss the deadline to best possible condition. 

<h4  class="w3-text-teal"  id="intro" > Introduction </h3>
CPU scheduling is the process by which a computer's operating system determines how, in what order, and for how long individual processes in a queue of processes are allowed to access the CPU. Input factors such as the chosen scheduling algorithm, the length of processes, and frequency of processes will have an influence on performance factors such as CPU utilization, average job waiting time, average job response time, and average job turn-around time. Depending on the application, the importance of some factors may weigh more heavily than others. For instance, a system that is designed for heavier human-computer-interaction may require lower average job response time in order to make the system appear more responsive. 
<p><b>In this project work we studied analysis of the following scheduling algorithms: </b></p>
<ul>
<li class="w3-text-teal" > Real Time Scheduling Algorithms </li>
<ol><li class="w3-text-teal" > Rate Monotonic Scheduling (RMS)
</li><li class="w3-text-teal" >Earliest Deadline First (EDF)
</li><li class="w3-text-teal" >Least Laxity First (LLF)
</li></ol></ul>
<ul>
<li class="w3-text-teal" >General Scheduling Algorithms </li>
<ol><li class="w3-text-teal" >Round Robin (RR)
</li><li class="w3-text-teal" >Priority based Round-Robin (PRR)
</li><li class="w3-text-teal" >First Come First Serve (FCFS)
</li></ol></ul>
<ul>
<li class="w3-text-teal" >Batch and Multilevel Scheduling Algorithms </li>
<ol><li class="w3-text-teal" > Shortest Process Next (SPN)
</li><li class="w3-text-teal" >Shortest Remaining Time (SRT)
</li><li class="w3-text-teal" >Highest Response Ratio Next (HRRN)
</li><li class="w3-text-teal" >Multilevel Queue Scheduling algorithm
</li><li class="w3-text-teal" >Multilevel Feedback Queue Scheduling algorithm
</li></ol></ul>
<p><b>And We will observe the following output metrics:</b></p>
<ol><li class="w3-text-teal" > Job Throughput
</li><li class="w3-text-teal" >CPU Utilization
</li><li class="w3-text-teal" > Average Turnaround Time
</li><li class="w3-text-teal" > Average Response Time
</li><li class="w3-text-teal" > Average Waiting Time
</li></ol></ul>
<h5 class="w3-text-teal" id="param" > Performance metrics </h5>
<ol> <li class="w3-text-teal" >Job Throughput :</li>
This is simply the number of jobs per unit of time [2]. Throughout this report, time will always be measured in milliseconds.

 <li class="w3-text-teal" >CPU Utilization :</li>
This number, given as a percent, is an indication of the amount of time that the CPU has spent doing useful work as opposed to time spent context switching [2]. A context switch occurs when a process is preempted. The system must stop what it is doing, package up the current process's work environment, and move all of this safely to a storage area to be worked on later and to make room for the incoming process. This switching of tasks in and out is pure overhead and should be minimized in an efficient algorithm.

<li class="w3-text-teal" > Average Turnaround Time: </li>
This is the amount of time it takes to service a process from arrival to completion [2].

 <li class="w3-text-teal" > Average Response Time: </li>
This is the amount of time it takes from the moment a process arrives to the moment we see the first response from the process, that is the first instant in which the process is being serviced [2].

 <li class="w3-text-teal" >Average Waiting Time: </li>
This is the total amount of time a scheduled process spends waiting, including time spent waiting for its first turn at the CPU as well as time spent waiting after being preempted by a higher priority process [2].
</ol>

<h4  class="w3-text-teal" id="algs" >Scheduling Algorithms</h4>
<h5 class="w3-text-teal">Earliest Deadline First (EDF)</h5>
<p>
Based on the EDF algorithm, priority of task is assigned according to its absolute deadline [14]. Highest priority is given to the task in the task set available on the base of earliest deadline. This is dynamic and preemptive scheduling. The schedulability is predictive, and optimal for uni-processor system. 
</p>
<h5 class="w3-text-teal">Least Laxity First (LLF) </h5>
<p>
In the Least-Laxity-First (LLF) scheduling algorithm a task whose laxity or slack is the least is given highest priority. The laxity or slack is defined as the difference of the task deadline and the burst time. This algorithm has been proved to be optimal for a uni-processor system. It is preemptive type scheduling and is less predictive. [24].
</p>
<h5 class="w3-text-teal"> First Come First Served (FCFS) </h5>
<p>
In the FCFS scheduling, tasks are implemented on first come, first serve basis. It can be a non-preemptive as well as preemptive scheduling algorithm based on the necessities. The implementation of FCFS is based on FIFO queue. The limitation of FCFS scheduling is its poor presentation as average wait time is high [27]. Jobs are processed in the order that they arrive [2]. For example, process P0 is the first to arrive at time t0 and no other processes are enqueued or are being serviced. P0 has a burst duration of 3. P0 is immediately serviced and continues to be serviced through to time t3. P1 showed up at time t1, but because the CPU was busy at the time, P1 is not serviced until time t3. Likewise, with any other processes that arrive while the CPU is busy, they are enqueued for later scheduling. Arrival does not guarantee immediate service, however earlier arrival does ensure higher priority for later scheduling. 
</p>
<h5 class="w3-text-teal"> Round Robin (RR) </h5>
<p>
Jobs are time sliced and interleaved over time, allocating a certain quantum of time to each enqueued process [2]. For example, P0 and P1 arrive at the same time t0 and no other processes are enqueued or are being serviced. The CPU alternates between servicing P0 and P1 over equal quanta of times until both processes are completed. If other processes arrive while P0 and P1 are being serviced, they join the back of the queue and are rotated into the cycle. If the remaining burst duration of a particular process is less than the time chosen for the service quantum, the scheduler simply moves to the next item in the queue.
<p>
<h5 class="w3-text-teal">Priority-based Round-Robin (PRR)</h5>
<p>
Priority based round robin has less number of context switches in comparison to simple round robin for same value of time quantum. The priorities may be assigned based upon deadline,burst time or other criteria [5]. 
</p>
<h5 class="w3-text-teal"> Shortest process next (SPN) </h5>
<p>
Shortest process next (SPN) is non-preemptive. The task priorities are assigned based upon
their burst time. Then a task with least burst time is assigned highest priority and executed in
queue. As obviously, this will increase throughput but a risk of starvation for long processes [1].
Jobs are prioritized by job burst duration [2]. For example, P0 and P1 arrive at the same time t0 and no other processes are enqueued or are being serviced. The CPU chooses the shorter of the two jobs, assume for example that the shorter job was P0, and leaves the other, P1, in the queue. While the CPU is servicing P0, other jobs may show up and join P1 in the queue. The fact that P1 arrived before those jobs has no bearing on their priority in this queue. If one of the jobs that has come along happens to be shorter than P1, it will jump to the front of the line and will be scheduled to receive service before P1. This scheduling algorithm allows for the possibility of starvation. It is possible that P1 may never get a turn at the CPU if a continuous stream of shorter jobs is in fresh supply to cut in front of P1.
</p>
<h5 class="w3-text-teal"> Shortest Remaining Time (SRT) </h5>
This is preemptive type of scheduling and criteria is based upon the burst time. The scheduling point is check each time a task is added. The task with least remaining burst time is given highest priority. Starvation is prevented but task switching is large in this type of scheduling [1].Jobs are prioritized by job burst duration but allowing for preemption by shorter, newly-arriving processes [2]. For example, P0 and P1 arrive at the same time t0 and no other processes are enqueued or are being serviced. The CPU chooses the shorter of the two jobs, assume for example the shorter job was P0, and leaves the other, P1, in the queue. While the CPU is servicing P0, other jobs may show up and if they happen to be shorter in burst duration than the amount of remaining time left to finish servicing P0 as well as the burst duration of P1, then not only do they get to cut in front of P1, but also P0 is preempted. P0 is then shoved back into the queue unfinished and the shorter job is then serviced immediately. P0 will rise to the front of the queue again when its remaining burst duration is less than the remaining burst duration of any other process.

<h5 class="w3-text-teal"> Highest Response Ratio Next (HRRN) </h5>
<p>
HRRN scheduling is a oo-line and non-preemptive type of scheduling. Task priority in this algorithm is not only dependent on its estimated burst time, but also of its waiting time spent before execution. However, HRRN favors the short processes, but the long processes gain higher priority as they wait, which prevents process starvation [37].
</p>
<h5 class="w3-text-teal">Multilevel Queue Scheduling algorithm </h5> 
<p>
A multilevel queue scheduling algorithm partitions the ready queue in several separate queues, in a multilevel queue scheduling tasks are permanently assigned to one queues. Algorithms choose the task from the occupied queue that has the highest priority, and run that tasks either preemptive or non-preemptive manner. Each queue has its own scheduling algorithm e.g Round Robin in first, FCFS in second and EDF in third queue in a three queue scheduling.The task cannot be switched in between the queues and priority of first queue is highest [1].
</p>
<h5 class="w3-text-teal"> Multilevel Feedback Queue Scheduling algorithm </h5>
<p>
This Scheduling is like Multilevel Queue(MLQ) Scheduling but in this tasks can be switched between the queues. Multilevel Feedback Queue Scheduling (MLFQ) keep analyzing the behavior (time of execution) of tasks and according to which it changes its priority by assigning the task to the different queue [1].
</p>
<h5 class="w3-text-teal"> POSIX Dynamic Priorities Scheduling (POSIX) </h5>
<p>
POSIX Dynamic Priorities Scheduling algorithm is another preemptive scheduling algorithm that was designed to counter the starvation scenario presented in the SJF algorithm as well as assign different classes of priorities to different types of processes. Priorities are recalculated for all enqueued processes on a set schedule such that priority = (recent CPU usage/2) + base, where recent CPU usage is how much time the given process has spent at the CPU and base is a tunable, implementation-specific factor [2]. This algorithm ensures that processes that have seen the CPU but were preempted will not be starved out by incoming processes, and thus will eventually be allowed to finish.
</p>
    </div>

</div>

  <!-- Pagination -->
  <div class="w3-center w3-padding-32">
    <div class="w3-bar">
      <a class="w3-button w3-black" href="#">1</a>
      <a class="w3-button w3-hover-black" href="#">2</a>
      <a class="w3-button w3-hover-black" href="#">3</a>
      <a class="w3-button w3-hover-black" href="#">4</a>
      <a class="w3-button w3-hover-black" href="#">5</a>
      <a class="w3-button w3-hover-black" href="#">»</a>
    </div>
  </div>

  <footer id="myFooter">
    <div class=" w3-bottombar w3-container w3-theme-l2 w3-padding-small">
      <h4>Footer</h4>
    </div>
  </footer>

<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
    if (mySidebar.style.display === 'block') {
        mySidebar.style.display = 'none';
        overlayBg.style.display = "none";
    } else {
        mySidebar.style.display = 'block';
        overlayBg.style.display = "block";
    }
}

// Close the sidebar with the close button
function w3_close() {
    mySidebar.style.display = "none";
    overlayBg.style.display = "none";
}
</script>

</body>
</html>

